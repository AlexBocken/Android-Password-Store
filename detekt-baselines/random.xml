<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ComplexCondition:RandomPhonemesGenerator.kt$RandomPhonemesGenerator$!candidate.flags.hasFlag(nextBasicType) || (isStartOfPart &amp;&amp; candidate.flags hasFlag NOT_FIRST) || // Don't let a diphthong that starts with a vowel follow a vowel. (previousFlags hasFlag VOWEL &amp;&amp; candidate.flags hasFlag VOWEL &amp;&amp; candidate.flags hasFlag DIPHTHONG) || // Don't add multi-character candidates if we would go over the targetLength. (password.length + candidate.length > targetLength) || (pwFlags hasFlag PasswordGenerator.NO_AMBIGUOUS &amp;&amp; candidate.isAmbiguous)</ID>
    <ID>ComplexMethod:PasswordGenerator.kt$PasswordGenerator$@Throws(PasswordGeneratorException::class) public fun generate(passwordOptions: List&lt;PasswordOption>, length: Int = DEFAULT_LENGTH): String</ID>
    <ID>ComplexMethod:RandomPhonemesGenerator.kt$RandomPhonemesGenerator$fun generate(targetLength: Int, pwFlags: Int): String?</ID>
    <ID>LongMethod:RandomPhonemesGenerator.kt$RandomPhonemesGenerator$fun generate(targetLength: Int, pwFlags: Int): String?</ID>
    <ID>LoopWithTooManyJumpStatements:RandomPhonemesGenerator.kt$RandomPhonemesGenerator$while (password.length &lt; targetLength) { // First part: Add a single letter or pronounceable pair of letters in varying case. val candidate = elements.secureRandomElement() // Reroll if the candidate does not fulfill the current requirements. if ( !candidate.flags.hasFlag(nextBasicType) || (isStartOfPart &amp;&amp; candidate.flags hasFlag NOT_FIRST) || // Don't let a diphthong that starts with a vowel follow a vowel. (previousFlags hasFlag VOWEL &amp;&amp; candidate.flags hasFlag VOWEL &amp;&amp; candidate.flags hasFlag DIPHTHONG) || // Don't add multi-character candidates if we would go over the targetLength. (password.length + candidate.length > targetLength) || (pwFlags hasFlag PasswordGenerator.NO_AMBIGUOUS &amp;&amp; candidate.isAmbiguous) ) { continue } // At this point the candidate could be appended to the password, but we still have // to determine the case. If no upper case characters are required, we don't add // any. val useUpperIfBothCasesAllowed = (isStartOfPart || candidate.flags hasFlag CONSONANT) &amp;&amp; secureRandomBiasedBoolean(20) password += if ( pwFlags hasFlag PasswordGenerator.UPPERS &amp;&amp; (!(pwFlags hasFlag PasswordGenerator.LOWERS) || useUpperIfBothCasesAllowed) ) { candidate.upperCase } else { candidate.lowerCase } // We ensured above that we will not go above the target length. check(password.length &lt;= targetLength) if (password.length == targetLength) break // Second part: Add digits and symbols with a certain probability (if requested) if // they would not directly follow the first character in a pronounceable part. if ( !isStartOfPart &amp;&amp; pwFlags hasFlag PasswordGenerator.DIGITS &amp;&amp; secureRandomBiasedBoolean(30) ) { var randomDigit: Char do { randomDigit = secureRandomNumber(10).toString(10).first() } while ( pwFlags hasFlag PasswordGenerator.NO_AMBIGUOUS &amp;&amp; randomDigit in PasswordGenerator.AMBIGUOUS_STR ) password += randomDigit // Begin a new pronounceable part after every digit. isStartOfPart = true nextBasicType = if (secureRandomBoolean()) VOWEL else CONSONANT previousFlags = 0 continue } if ( !isStartOfPart &amp;&amp; pwFlags hasFlag PasswordGenerator.SYMBOLS &amp;&amp; secureRandomBiasedBoolean(20) ) { var randomSymbol: Char do { randomSymbol = PasswordGenerator.SYMBOLS_STR.secureRandomCharacter() } while ( pwFlags hasFlag PasswordGenerator.NO_AMBIGUOUS &amp;&amp; randomSymbol in PasswordGenerator.AMBIGUOUS_STR ) password += randomSymbol // Continue the password generation as if nothing was added. } // Third part: Determine the basic type of the next character depending on the letter // we just added. nextBasicType = when { candidate.flags.hasFlag(CONSONANT) -> VOWEL previousFlags.hasFlag(VOWEL) || candidate.flags.hasFlag(DIPHTHONG) || secureRandomBiasedBoolean(60) -> CONSONANT else -> VOWEL } previousFlags = candidate.flags isStartOfPart = false }</ID>
    <ID>MagicNumber:PasswordGenerator.kt$PasswordGenerator$1000</ID>
    <ID>MagicNumber:PasswordGenerator.kt$PasswordGenerator$6</ID>
    <ID>MagicNumber:RandomNumberGenerator.kt$100</ID>
    <ID>MagicNumber:RandomNumberGenerator.kt$99</ID>
    <ID>MagicNumber:RandomPhonemesGenerator.kt$RandomPhonemesGenerator$10</ID>
    <ID>MagicNumber:RandomPhonemesGenerator.kt$RandomPhonemesGenerator$20</ID>
    <ID>MagicNumber:RandomPhonemesGenerator.kt$RandomPhonemesGenerator$30</ID>
    <ID>MagicNumber:RandomPhonemesGenerator.kt$RandomPhonemesGenerator$60</ID>
    <ID>ReturnCount:PasswordGenerator.kt$PasswordGenerator$internal fun isValidPassword(password: String, pwFlags: Int): Boolean</ID>
    <ID>ThrowsCount:PasswordGenerator.kt$PasswordGenerator$@Throws(PasswordGeneratorException::class) public fun generate(passwordOptions: List&lt;PasswordOption>, length: Int = DEFAULT_LENGTH): String</ID>
  </CurrentIssues>
</SmellBaseline>
