<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>ComplexMethod:AutofillStrategyDsl.kt$AutofillRule$fun match( allPassword: List&lt;FormField&gt;, allUsername: List&lt;FormField&gt;, allOtp: List&lt;FormField&gt;, singleOriginMode: Boolean, isManualRequest: Boolean ): AutofillScenario&lt;FormField&gt;?</ID>
    <ID>DestructuringDeclarationWithTooManyEntries:AutofillStrategyDsl.kt$AutofillRule$(type, matcher, optional, matchHidden)</ID>
    <ID>ForbiddenComment:AutofillFormParser.kt$AutofillFormParser$// TODO: Support WebViews in apps via Digital Asset Links</ID>
    <ID>ForbiddenComment:AutofillStrategy.kt$// TODO: Introduce a custom fill/generate/update flow for this scenario</ID>
    <ID>ForbiddenComment:FormField.kt$FormField$// TODO: Revisit this decision in the future</ID>
    <ID>LongMethod:ByteArray.kt$@Suppress("ComplexMethod", "NestedBlockDepth") internal fun ByteArray.binarySearch(labels: List&lt;ByteArray&gt;, labelIndex: Int): String?</ID>
    <ID>LoopWithTooManyJumpStatements:AutofillStrategyDsl.kt$PairOfFieldsMatcher$for ((i, tieBreaker) in tieBreakers.withIndex()) { val new = current.filter { tieBreaker(it, alreadyMatched) } if (new.isEmpty()) { logcat { "Tie breaker #${i + 1}: Didn't match any pair of fields; skipping" } continue } // and return if the available options have been narrowed to a single field. if (new.size == 1) { logcat { "Tie breaker #${i + 1}: Success" } current = new break } logcat { "Tie breaker #${i + 1}: Matched ${new.size} pairs of fields; continuing" } current = new }</ID>
    <ID>LoopWithTooManyJumpStatements:AutofillStrategyDsl.kt$SingleFieldMatcher$for ((i, tieBreaker) in tieBreakers.withIndex()) { // Successively filter matched fields via tie breakers... val new = current.filter { tieBreaker(it, alreadyMatched) } // skipping those tie breakers that are not satisfied for any remaining field... if (new.isEmpty()) { logcat { "Tie breaker #${i + 1}: Didn't match any field; skipping" } continue } // and return if the available options have been narrowed to a single field. if (new.size == 1) { logcat { "Tie breaker #${i + 1}: Success" } current = new break } logcat { "Tie breaker #${i + 1}: Matched ${new.size} fields; continuing" } current = new }</ID>
    <ID>LoopWithTooManyJumpStatements:ByteArray.kt$while (true) { val byte0 = if (expectDot) { expectDot = false '.'.code.toByte() } else { labels[currentLabelIndex][currentLabelByteIndex] and BITMASK } val byte1 = this[start + publicSuffixByteIndex] and BITMASK // Compare the bytes. Note that the file stores UTF-8 encoded bytes, so we must compare // the // unsigned bytes. compareResult = (byte0.toUByte() - byte1.toUByte()).toInt() if (compareResult != 0) { break } publicSuffixByteIndex++ currentLabelByteIndex++ if (publicSuffixByteIndex == publicSuffixLength) { break } if (labels[currentLabelIndex].size == currentLabelByteIndex) { // We've exhausted our current label. Either there are more labels to compare, in // which // case we expect a dot as the next character. Otherwise, we've checked all our // labels. if (currentLabelIndex == labels.size - 1) { break } else { currentLabelIndex++ currentLabelByteIndex = -1 expectDot = true } } }</ID>
    <ID>MagicNumber:AutofillHelper.kt$FixedSaveCallback$29</ID>
    <ID>MagicNumber:AutofillScenario.kt$4</ID>
    <ID>MagicNumber:AutofillScenario.kt$5</ID>
    <ID>MaxLineLength:FormField.kt$FormField$"\"$hint\", \"$fieldId\"${if (isFocused) ", focused" else ""}${if (isVisible) ", visible" else ""}, $webOrigin, $htmlAttributesDebug, $autofillHints"</ID>
    <ID>ReturnCount:AutofillFormParser.kt$AutofillFormParser$private fun determineFormOrigin(context: Context): FormOrigin?</ID>
    <ID>ReturnCount:AutofillFormParser.kt$AutofillFormParser$private fun webOriginToFormOrigin(context: Context, origin: String): FormOrigin?</ID>
    <ID>ReturnCount:AutofillFormParser.kt$FormOrigin.Companion$public fun fromBundle(bundle: Bundle): FormOrigin?</ID>
    <ID>ReturnCount:AutofillStrategyDsl.kt$AutofillRule$fun match( allPassword: List&lt;FormField&gt;, allUsername: List&lt;FormField&gt;, allOtp: List&lt;FormField&gt;, singleOriginMode: Boolean, isManualRequest: Boolean ): AutofillScenario&lt;FormField&gt;?</ID>
    <ID>ReturnCount:PublicSuffixListCache.kt$private fun getSuffixPlusUpToOne(domain: String, suffix: String): String?</ID>
    <ID>ReturnCount:PublicSuffixListData.kt$PublicSuffixListData$private fun findExceptionMatch(labels: List&lt;ByteArray&gt;, wildcardMatch: String?): String?</ID>
    <ID>ReturnCount:PublicSuffixListData.kt$PublicSuffixListData$private fun findMatchingRule(domainLabels: List&lt;String&gt;): List&lt;String&gt;</ID>
    <ID>TooGenericExceptionCaught:AutofillScenario.kt$AutofillScenario.Companion$e: Throwable</ID>
    <ID>TopLevelPropertyNaming:PublicSuffixListLoader.kt$private const val PUBLIC_SUFFIX_LIST_FILE = "publicsuffixes"</ID>
    <ID>UnusedPrivateMember:AutofillStrategy.kt$private inline fun &lt;T&gt; Pair&lt;T, T&gt;.none(predicate: T.() -&gt; Boolean)</ID>
    <ID>UnusedPrivateMember:FormField.kt$FormField$// Ignored for now, see excludedByHints private val excludedByAutocompleteHint = htmlAutocomplete == "off"</ID>
  </CurrentIssues>
</SmellBaseline>
